<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>【書誌】詳解システムパフォーマンス - suzmemo</title><meta name=description content="まえがき 1章　イントロダクション 1.1　システムパフォーマンス 1.2　職種 1.3　作業 1.4　分析の視点 1.5　パフォーマンスエンジニアリングの難しさと面白さ 1.5.1　主観的な性質 1.5.2　複雑さ 1.5.3　複数の原因の相互作用 1.5.4　複数のパフォーマンス障害の同時発生 1.6　レイテンシ 1.7　可観測性 1.7.1　カウンタ、統計量、指標 1.7.2　プロファイリング 1.7.3　トレーシング 1.8　実験 1.9　クラウドコンピューティング 1.10　メソドロジ 1.10.1　60秒で終わるLinuxパフォーマンス分析 1.11　ケーススタディ 1.11.1　ディスクの速度低下 1.11.2　ソフトウェア変更 1.11.3　より深く学ぶために 1.12　参考文献 2章　メソドロジ 2.1　用語 2.2　モデル 2.2.1　テスト対象システム（SUT） 2.2.2　キューイングシステム 2.3　コンセプト 2.3.1　レイテンシ 2.3.2　タイムスケール 2.3.3　トレードオフ 2.3.4　チューニング 2.3.5　適切性のレベル 2."><meta name=author content><link href=https://unpkg.com/@master/normal.css rel=stylesheet><script src=https://unpkg.com/@master/style@1.5.0></script>
<script src=https://unpkg.com/@master/styles@1.13.0></script>
<script src=https://unpkg.com/master-styles-group></script>
<script src=https://unpkg.com/themes.js></script>
<script>window.themes=window.themes||new window.Themes</script><style>:root{--font-sans:"Inter var", ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica Neue, Arial, Noto Sans, sans-serif, Apple Color Emoji, Segoe UI Emoji, Segoe UI Symbol, Noto Color Emoji}</style></head><body class="bg:fade-84@dark font:fade-16@dark font:sans"><nav class="w:full h:90 fixed bg:fade-84/.95@dark bg:white z:1000"><div class="h:full
w:full
max-w:1200
mx:auto
px:32
d:flex
align-items:center"><div><a href=/ class="mr-3 font:extralight">suzmemo</a></div><div class=ml:auto><a class="font:semibold
font:fade
font:fade-10:hover
font:fade-30.active
px:8
transition:150ms;ease-in" href=/suzmemo/ title>Home</a>
<a class="font:semibold
font:fade
font:fade-10:hover
font:fade-30.active
px:8
transition:150ms;ease-in" href=/suzmemo/about/ title>About</a>
<a class="font:semibold
font:fade
font:fade-10:hover
font:fade-30.active
px:8
transition:150ms;ease-in" href=index.xml title>Subscribe</a></div></div></nav><div class="d:flex flex:column@<=sm pt:90 px:24 jc:center gap:44 word-break:break-word"><div class="max-w:700 w:full box:content-box"><article class="box:border-box pt:32"><header class=mb:32><div class="font:40 font:extrabold">【書誌】詳解システムパフォーマンス</div><div class="mt:16 f:fade-60"><time>Aug 15, 2023</time></div></header><div class="_:where(a):hover{text-decoration-color:fade}
_:where(a){text-decoration:2;underline;fade-10;_text-decoration-color:fade-70@dark}
_:where(blockquote){bl:5;solid;fade-76/.1;_bl:5;solid;fade-34/.1@dark}
_:where(code){font:90%;_v:middle}
_:where(code:not(.highlight_*,pre_*)){p:2;6;_r:4}
_:where(del){text-decoration:1;line-through;fade-68;_text-decoration-color:red-64@dark}
_:where(figcaption){text:14;_p:10;20;0;_width:fit;_mx:auto;_font:fade-56;_font:fade-57@dark}
_:where(h1){font:40;_font:extrabold}
_:where(h1,h2,h3)+:where(h1,h2,h3){mt:.5em}
_:where(h1,h2,h3,h4,h5,h6){mt:2em}
_:where(h2){mb:1em;_font:32}
_:where(h3){font:24}
_:where(h4){font:20}
_:where(h5){font:16}
_:where(h6){font:14}
_:where(li)::marker{font:fade-44;_font:fade-68@dark}
_:where(li){pl:.375em}
_:where(mark){text-decoration:1;underline;#fce016;_bg:transparent;_text-decoration-color:rgb(252;224;22/.5)@dark}
_:where(p,li){font:fade-76;_font:16;_line-height:1.65;_font:fade-34@dark}
_:where(p,pre,blockquote,figure,ul,ol,table){my:1.125em}
>:first-child{mt:0!}
_:where(pre){p:20;_r:8;_overflow:auto}
_:where(pre,code:not(.highlight_*)){bg:fade-2;_bg:fade-92!@dark}
_:where(strong,b,a,code:not(.highlight_*),mark,del){font:fade-92;_font:fade-12@dark}
_:where(table){width:full;_border-spacing:0}
_:where(td){v:baseline}
_:where(td,th):first-child{pl:0}
_:where(td,th):last-child{pr:0}
_:where(td,th){bb:1;solid;fade-92/.06;_p:6;_b:fade-4/.04@dark}
_:where(th){font:fade-78;_font:14;_text:left;_font:fade-12@dark}
_:where(th,p_code,li_code,a,mark){font:semibold;_font:medium@dark}
_:where(ul){list-style-type:disc}
_:where(ul,ol,blockquote){pl:1.5em}
_:where(video,img){max-width:full}
_:where(a,mark){text-underline-offset:3}
_:where(hr){h:2;_bg:fade-10;_bg:fade-70@dark;_my:3em}"><pre tabindex=0><code>まえがき

1章　イントロダクション
    1.1　システムパフォーマンス
    1.2　職種
    1.3　作業
    1.4　分析の視点
    1.5　パフォーマンスエンジニアリングの難しさと面白さ
        1.5.1　主観的な性質
        1.5.2　複雑さ
        1.5.3　複数の原因の相互作用
        1.5.4　複数のパフォーマンス障害の同時発生
    1.6　レイテンシ
    1.7　可観測性
        1.7.1　カウンタ、統計量、指標
        1.7.2　プロファイリング
        1.7.3　トレーシング
    1.8　実験
    1.9　クラウドコンピューティング
    1.10　メソドロジ
        1.10.1　60秒で終わるLinuxパフォーマンス分析
    1.11　ケーススタディ
        1.11.1　ディスクの速度低下
        1.11.2　ソフトウェア変更
        1.11.3　より深く学ぶために
    1.12　参考文献

2章　メソドロジ
    2.1　用語
    2.2　モデル
        2.2.1　テスト対象システム（SUT）
        2.2.2　キューイングシステム
    2.3　コンセプト
        2.3.1　レイテンシ
        2.3.2　タイムスケール
        2.3.3　トレードオフ
        2.3.4　チューニング
        2.3.5　適切性のレベル
        2.3.6　いつ分析を止めるか
        2.3.7　基準時の推奨値
        2.3.8　負荷かアーキテクチャか
        2.3.9　スケーラビリティ
        2.3.10　パフォーマンス指標
        2.3.11　使用率
        2.3.12　飽和度
        2.3.13　プロファイリング
        2.3.14　キャッシング
        2.3.15　Known-Unknowns
    2.4　視点
        2.4.1　リソース分析
        2.4.2　ワークロード分析
    2.5　メソドロジ
        2.5.1　街灯のアンチメソッド
        2.5.2　ランダム変更アンチメソッド
        2.5.3　誰か他人のせいにするアンチメソッド
        2.5.4　アドホックチェックリストメソッド
        2.5.5　問題の記述
        2.5.6　科学的メソッド
        2.5.7　診断サイクル
        2.5.8　ツールメソッド
        2.5.9　USEメソッド
        2.5.10　REDメソッド
        2.5.11　ワークロードの特性の把握
        2.5.12　ドリルダウン分析
        2.5.13　レイテンシ分析
        2.5.14　メソッドR
        2.5.15　イベントトレーシング
        2.5.16　ベースライン統計
        2.5.17　静的パフォーマンスチューニング
        2.5.18　キャッシュのチューニング
        2.5.19　マイクロベンチマーキング
        2.5.20　パフォーマンスマントラ
    2.6　モデリング
        2.6.1　エンタープライズシステムかクラウドシステムか
        2.6.2　視覚的な究明
        2.6.3　スケーラビリティに関するアムダールの法則
        2.6.4　ユニバーサルスケーラビリティ法則
        2.6.5　待ち行列理論
    2.7　キャパシティプランニング
        2.7.1　リソースの限界
        2.7.2　要素分析
        2.7.3　スケーラビリティを向上させる方法
    2.8　統計量
        2.8.1　パフォーマンスゲインの定量化
        2.8.2　平均
        2.8.3　標準偏差、パーセンタイル、中央値
        2.8.4　変動係数
        2.8.5　多峰分布
        2.8.6　外れ値
    2.9　モニタリング
        2.9.1　時系列的なパターン
        2.9.2　モニタリングプロダクト
        2.9.3　ブート以降の集計
    2.10　ビジュアライゼーション
        2.10.1　折れ線グラフ
        2.10.2　散布図
        2.10.3　ヒートマップ
        2.10.4　タイムライン図
        2.10.5　表面プロット
        2.10.6　ビジュアライゼーションツール
    2.11　練習問題
    2.12　参考文献

3章　オペレーティングシステム
    3.1　用語
    3.2　基礎知識
        3.2.1　カーネル
        3.2.2　カーネルモードとユーザーモード
        3.2.3　システムコール
        3.2.4　割り込み
        3.2.5　クロックとアイドル状態
        3.2.6　プロセス
        3.2.7　スタック
        3.2.8　仮想メモリ
        3.2.9　スケジューラ
        3.2.10　ファイルシステム
        3.2.11　キャッシング
        3.2.12　ネットワーキング
        3.2.13　デバイスドライバ
        3.2.14　マルチプロセッサ
        3.2.15　プリエンプション
        3.2.16　リソースコントロール
        3.2.17　可観測性
    3.3　カーネル
        3.3.1　Unix
        3.3.2　BSD
        3.3.3　Solaris
    3.4　Linux
        3.4.1　Linuxが開発したカーネル機能
        3.4.2　systemd
        3.4.3　KPTI（メルトダウン対策）
        3.4.4　拡張BPF
    3.5　その他の項目
        3.5.1　PGOカーネル
        3.5.2　ユニカーネル
        3.5.3　マイクロカーネルとハイブリッドカーネル
        3.5.4　分散OS
    3.6　カーネルの比較
    3.7　練習問題
    3.8　参考文献
        3.8.1　本文で言及していない参考文献

4章　可観測性ツール
    4.1　取り上げるツール
        4.1.1　静的パフォーマンスツール
        4.1.2　クライシスツール
    4.2　ツールタイプ
        4.2.1　固定カウンタ
        4.2.2　プロファイリング
        4.2.3　トレーシング
        4.2.4　モニタリング
    4.3　可観測性ツールの情報ソース
        4.3.1　/proc
        4.3.2　/sys
        4.3.3　遅延アカウンティング
        4.3.4　netlink
        4.3.5　トレースポイント
        4.3.6　kprobe
        4.3.7　uprobe
        4.3.8　USDT
        4.3.9　ハードウェアカウンタ（PMC）
        4.3.10　可観測性ツールのその他の情報ソース
    4.4　sar
        4.4.1　sar(1)でできること
        4.4.2　sar(1)モニタリング
        4.4.3　sar(1)のライブ出力
        4.4.4　sar(1)のドキュメント
    4.5　トレーシングツール
    4.6　可観測性ツールに対する観察
    4.7　練習問題
    4.8　参考文献

5章　アプリケーション
    5.1　アプリケーションの基礎知識
        5.1.1　パフォーマンスの目標
        5.1.2　よく実行されるコードの最適化
        5.1.3　可観測性
        5.1.4　ビッグオー記法
    5.2　アプリケーションのパフォーマンス向上のためのテクニック
        5.2.1　I/Oサイズの選択
        5.2.2　キャッシング
        5.2.3　バッファリング
        5.2.4　ポーリング
        5.2.5　並行実行と並列処理
        5.2.6　ノンブロッキングI/O
        5.2.7　プロセッサのバインド
        5.2.8　パフォーマンスマントラ
    5.3　プログラミング言語
        5.3.1　コンパイル言語
        5.3.2　インタープリタ言語
        5.3.3　仮想マシン
        5.3.4　ガベージコレクション
    5.4　メソドロジ
        5.4.1　CPUプロファイリング
        5.4.2　off-CPU分析
        5.4.3　システムコール分析
        5.4.4　USEメソッド
        5.4.5　スレッド状態の分析
        5.4.6　ロック分析
        5.4.7　静的パフォーマンスチューニング
        5.4.8　分散トレーシング
    5.5　可観測性ツール
        5.5.1　perf
        5.5.2　profile
        5.5.3　offcputime
        5.5.4　strace
        5.5.5　execsnoop
        5.5.6　syscount
        5.5.7　bpftrace
    5.6　注意点
        5.6.1　不明なシンボル
        5.6.2　不明なスタック
    5.7　練習問題
    5.8　参考文献

6章　CPU
    6.1　用語
    6.2　モデル
        6.2.1　CPUのアーキテクチャ
        6.2.2　CPUのメモリキャッシュ
        6.2.3　CPUのランキュー
    6.3　コンセプト
        6.3.1　クロックスピード
        6.3.2　命令
        6.3.3　命令パイプライン
        6.3.4　命令幅
        6.3.5　命令サイズ
        6.3.6　SMT
        6.3.7　IPC、CPI
        6.3.8　使用率
        6.3.9　ユーザー時間/カーネル時間
        6.3.10　飽和
        6.3.11　プリエンプション
        6.3.12　優先度の逆転
        6.3.13　マルチプロセスとマルチスレッディング
        6.3.14　ワードサイズ
        6.3.15　コンパイラの最適化
    6.4　アーキテクチャ
        6.4.1　ハードウェア
        6.4.2　ソフトウェア
    6.5　メソドロジ
        6.5.1　ツールメソッド
        6.5.2　USEメソッド
        6.5.3　ワークロードの特性の把握
        6.5.4　プロファイリング
        6.5.5　サイクル分析
        6.5.6　パフォーマンスモニタリング
        6.5.7　静的パフォーマンスチューニング
        6.5.8　優先度のチューニング
        6.5.9　リソースコントロール
        6.5.10　CPUのバインド
        6.5.11　マイクロベンチマーキング
    6.6　可観測性ツール
        6.6.1　uptime
        6.6.2　vmstat
        6.6.3　mpstat
        6.6.4　sar
        6.6.5　ps
        6.6.6　top
        6.6.7　pidstat
        6.6.8　time、ptime
        6.6.9　turbostat
        6.6.10　showboost
        6.6.11　pmcarch
        6.6.12　tlbstat
        6.6.13　perf
        6.6.14　profile
        6.6.15　cpudist
        6.6.16　runqlat
        6.6.17　runqlen
        6.6.18　softirqs
        6.6.19　hardirqs
        6.6.20　bpftrace
        6.6.21　その他のツール
    6.7　ビジュアライゼーション
        6.7.1　使用率ヒートマップ
        6.7.2　秒未満オフセットヒートマップ
        6.7.3　フレームグラフ
        6.7.4　FlameScope
    6.8　実験
        6.8.1　アドホックテスト
        6.8.2　SysBench
    6.9　チューニング
        6.9.1　コンパイラのオプション
        6.9.2　優先度とクラスの操作
        6.9.3　スケジューラオプション
        6.9.4　スケーリングガバナー
        6.9.5　電力状態
        6.9.6　CPUへのバインド
        6.9.7　排他的cpuset
        6.9.8　リソースコントロール
        6.9.9　セキュリティブートオプション
        6.9.10　プロセッサオプション（BIOSチューニング）
    6.10　練習問題
    6.11　参考文献

7章　メモリ
    7.1　用語
    7.2　コンセプト
        7.2.1　仮想メモリ
        7.2.2　ページング
        7.2.3　デマンドページング
        7.2.4　オーバーコミット
        7.2.5　プロセスのスワッピング
        7.2.6　ファイルシステムキャッシュの使い方
        7.2.7　使用率と飽和
        7.2.8　アロケータ
        7.2.9　共有メモリ
        7.2.10　ワーキングセットサイズ
        7.2.11　ワードサイズ
    7.3　アーキテクチャ
        7.3.1　ハードウェア
        7.3.2　ソフトウェア
        7.3.3　プロセスの仮想アドレス空間
    7.4　メソドロジ
        7.4.1　ツールメソッド
        7.4.2　USEメソッド
        7.4.3　使用形態の特性の把握
        7.4.4　サイクル分析
        7.4.5　パフォーマンスモニタリング
        7.4.6　リーク検出
        7.4.7　静的パフォーマンスチューニング
        7.4.8　リソースコントロール
        7.4.9　マイクロベンチマーキング
        7.4.10　メモリシュリンク
    7.5　可観測性ツール
        7.5.1　vmstat
        7.5.2　PSI
        7.5.3　swapon
        7.5.4　sar
        7.5.5　slabtop
        7.5.6　numastat
        7.5.7　ps
        7.5.8　top
        7.5.9　pmap
        7.5.10　perf
        7.5.11　drsnoop
        7.5.12　wss
        7.5.13　bpftrace
        7.5.14　その他のツール
    7.6　チューニング
        7.6.1　パラメータ
        7.6.2　複数のページサイズ
        7.6.3　アロケータ
        7.6.4　NUMAバインディング
        7.6.5　リソースコントロール
    7.7　練習問題
    7.8　参考文献

8章　ファイルシステム
    8.1　用語
    8.2　モデル
        8.2.1　ファイルシステムインターフェイス
        8.2.2　ファイルシステムキャッシュ
        8.2.3　2次キャッシュ
    8.3　コンセプト
        8.3.1　ファイルシステムレイテンシ
        8.3.2　キャッシング
        8.3.3　ランダムI/Oとシーケンシャル I/O
        8.3.4　プリフェッチ
        8.3.5　先読み
        8.3.6　ライトバックキャッシング
        8.3.7　同期書き込み
        8.3.8　Raw I/OとDirect I/O
        8.3.9　ノンブロッキングI/O
        8.3.10　メモリマップトファイル
        8.3.11　メタデータ
        8.3.12　論理I/Oと物理 I/O
        8.3.13　オペレーションは平等ではない
        8.3.14　特殊ファイルシステム
        8.3.15　最終アクセス時刻
        8.3.16　容量
    8.4　アーキテクチャ
        8.4.1　ファイルシステムI/Oスタック
        8.4.2　VFS
        8.4.3　ファイルシステムキャッシュ
        8.4.4　ファイルシステムのパフォーマンスに関わるその他の機能と属性
        8.4.5　ファイルシステムタイプ
        8.4.6　ボリュームとプール
    8.5　メソドロジ
        8.5.1　ディスク分析
        8.5.2　レイテンシ分析
        8.5.3　ワークロードの特性の把握
        8.5.4　パフォーマンスモニタリング
        8.5.5　静的パフォーマンスチューニング
        8.5.6　キャッシュのチューニング
        8.5.7　ワークロードの分離
        8.5.8　マイクロベンチマーキング
    8.6　可観測性ツール
        8.6.1　mount
        8.6.2　free
        8.6.3　top
        8.6.4　vmstat
        8.6.5　sar
        8.6.6　slabtop
        8.6.7　strace
        8.6.8　fatrace
        8.6.9　LatencyTOP
        8.6.10　opensnoop
        8.6.11　filetop
        8.6.12　cachestat
        8.6.13　ext4dist（xfs、zfs、btrfs、nfs）
        8.6.14　ext4slower（xfs、zfs、btrfs、nfs）
        8.6.15　bpftrace
        8.6.16　その他のツール
        8.6.17　ビジュアライゼーション
    8.7　実験
        8.7.1　アドホックテスト
        8.7.2　マイクロベンチマークツール
        8.7.3　キャッシュのフラッシュ
    8.8　チューニング
        8.8.1　アプリケーションからの呼び出し
        8.8.2　ext4
        8.8.3　ZFS
    8.9　練習問題
    8.10　参考文献

9章　ディスク
    9.1　用語
    9.2　モデル
        9.2.1　単純ディスク
        9.2.2　オンディスクキャッシュ
        9.2.3　コントローラ
    9.3　コンセプト
        9.3.1　時間の計測
        9.3.2　タイムスケール
        9.3.3　キャッシング
        9.3.4　ランダムI/Oとシーケンシャル I/O
        9.3.5　読み書きの割合
        9.3.6　I/Oサイズ
        9.3.7　IOPSは等しくない
        9.3.8　非データ転送ディスクコマンド
        9.3.9　使用率
        9.3.10　飽和度
        9.3.11　I/O待ち時間
        9.3.12　同期I/Oと非同期I/O
        9.3.13　ディスクI/OとアプリケーションI/O
    9.4　アーキテクチャ
        9.4.1　ディスクのタイプ
        9.4.2　インターフェイス
        9.4.3　ストレージタイプ
        9.4.4　OSのディスクI/Oスタック
    9.5　メソドロジ
        9.5.1　ツールメソッド
        9.5.2　USEメソッド
        9.5.3　パフォーマンスモニタリング
        9.5.4　ワークロードの特性の把握
        9.5.5　レイテンシ分析
        9.5.6　静的パフォーマンスチューニング
        9.5.7　キャッシュチューニング
        9.5.8　リソースコントロール
        9.5.9　マイクロベンチマーキング
        9.5.10　スケーリング
    9.6　可観測性ツール
        9.6.1　iostat
        9.6.2　sar
        9.6.3　PSI
        9.6.4　pidstat
        9.6.5　perf
        9.6.6　biolatency
        9.6.7　biosnoop
        9.6.8　iotop，biotop
        9.6.9　biostacks
        9.6.10　blktrace
        9.6.11　bpftrace
        9.6.12　MegaCli
        9.6.13　smartctl
        9.6.14　SCSIロギング
        9.6.15　その他のツール
    9.7　ビジュアライゼーション
        9.7.1　折れ線グラフ
        9.7.2　レイテンシ散布図
        9.7.3　レイテンシヒートマップ
        9.7.4　オフセットヒートマップ
        9.7.5　使用率ヒートマップ
    9.8　実験
        9.8.1　アドホックテスト
        9.8.2　カスタムロードジェネレータ
        9.8.3　マイクロベンチマークツール
        9.8.4　ランダム読み出しの例
        9.8.5　ioping
        9.8.6　fio
        9.8.7　blkreplay
    9.9　チューニング
        9.9.1　OSのパラメータ
        9.9.2　ディスクデバイスのパラメータ
        9.9.3　ディスクコントローラのパラメータ
    9.10　練習問題
    9.11　参考文献

10章　ネットワーク
    10.1　用語
    10.2　モデル
        10.2.1　ネットワークインターフェイス
        10.2.2　コントローラ
        10.2.3　プロトコルスタック
    10.3　コンセプト
        10.3.1　ネットワークとルーティング
        10.3.2　プロトコル
        10.3.3　カプセル化
        10.3.4　パケットサイズ
        10.3.5　レイテンシ
        10.3.6　バッファリング
        10.3.7　接続バックログ
        10.3.8　インターフェイスのネゴシエーション
        10.3.9　輻輳回避
        10.3.10　使用率
        10.3.11　ローカル接続
    10.4　アーキテクチャ
        10.4.1　プロトコル
        10.4.2　ハードウェア
        10.4.3　ソフトウェア
    10.5　メソドロジ
        10.5.1　ツールメソッド
        10.5.2　USEメソッド
        10.5.3　ワークロードの特性の把握
        10.5.4　レイテンシ分析
        10.5.5　パフォーマンスモニタリング
        10.5.6　パケットスニッフィング
        10.5.7　TCP分析
        10.5.8　静的パフォーマンスチューニング
        10.5.9　リソースコントロール
        10.5.10　マイクロベンチマーキング
    10.6　可観測性ツール
        10.6.1　ss
        10.6.2　ip
        10.6.3　ifconfig
        10.6.4　nstat
        10.6.5　netstat
        10.6.6　sar
        10.6.7　nicstat
        10.6.8　ethtool
        10.6.9　tcplife
        10.6.10　tcptop
        10.6.11　tcpretrans
        10.6.12　bpftrace
        10.6.13　tcpdump
        10.6.14　Wireshark
        10.6.15　その他のツール
    10.7　実験
        10.7.1　ping
        10.7.2　traceroute
        10.7.3　pathchar
        10.7.4　iperf
        10.7.5　netperf
        10.7.6　tc
        10.7.7　その他のツール
    10.8　チューニング
        10.8.1　システム全体でのチューニング
        10.8.2　ソケットオプション
        10.8.3　構成オプション
    10.9　練習問題
    10.10　参考文献

11章　クラウドコンピューティング
    11.1　基礎知識
        11.1.1　インスタンスタイプ
        11.1.2　スケーラブルなアーキテクチャ
        11.1.3　キャパシティプランニング
        11.1.4　ストレージ
        11.1.5　マルチテナンシー
        11.1.6　オーケストレーション（Kubernetes）
    11.2　ハードウェア仮想化
        11.2.1　実装
        11.2.2　オーバーヘッド
        11.2.3　リソースコントロール
        11.2.4　可観測性
    11.3　OS仮想化
        11.3.1　実装
        11.3.2　オーバーヘッド
        11.3.3　リソースコントロール
        11.3.4　可観測性
    11.4　軽量仮想化
        11.4.1　実装
        11.4.2　オーバーヘッド
        11.4.3　リソースコントロール
        11.4.4　可観測性
    11.5　その他のタイプ
    11.6　比較
    11.7　演習問題
    11.8　参考文献

12章　ベンチマーキング
    12.1　基礎知識
        12.1.1　理由
        12.1.2　効果的なベンチマーキング
        12.1.3　まずいベンチマーキング
    12.2　ベンチマーキングのタイプ
        12.2.1　マイクロベンチマーキング
        12.2.2　シミュレーション
        12.2.3　リプレイ
        12.2.4　産業標準
    12.3　メソドロジ
        12.3.1　パッシブベンチマーキング
        12.3.2　アクティブベンチマーキング
        12.3.3　CPUプロファイリング
        12.3.4　USEメソッド
        12.3.5　ワークロードの特性の把握
        12.3.6　カスタムベンチマーク
        12.3.7　ランプ負荷
        12.3.8　サニティチェック
        12.3.9　統計的分析
        12.3.10　ベンチマーキングのチェックリスト
    12.4　ベンチマークについて問うべきこと
    12.5　練習問題
    12.6　参考文献

13章　perf
    13.1　サブコマンドの概要
    13.2　1行プログラム
        13.2.1　イベントのリストの表示
        13.2.2　イベント数の計算
        13.2.3　プロファイリング
        13.2.4　静的トレーシング
        13.2.5　動的トレーシング
        13.2.6　レポート作成
    13.3　perfイベント
    13.4　ハードウェアイベント
        13.4.1　周波数サンプリング
    13.5　ソフトウェアイベント
    13.6　トレースポイントイベント
    13.7　プローブイベント
        13.7.1　kprobe
        13.7.2　uprobe
        13.7.3　USDT
    13.8　perf stat
        13.8.1　オプション
        13.8.2　インターバルごとの統計
        13.8.3　CPU間のバランス
        13.8.4　イベントフィルタ
        13.8.5　シャドウ統計
    13.9　perf record
        13.9.1　オプション
        13.9.2　CPUプロファイリング
        13.9.3　スタックウォーク
    13.10　perf report
        13.10.1　TUI
        13.10.2　STDIO
    13.11　perf script
        13.11.1　フレームグラフ
        13.11.2　トレーススクリプト
    13.12　perf trace
        13.12.1　カーネルのバージョンによる違い
    13.13　その他のコマンド
    13.14　perfのドキュメント
    13.15　参考文献

14章　Ftrace
    14.1　機能の概要
    14.2　tracefs（/sys）
        14.2.1　tracefsの内容
    14.3　Ftraceの関数プロファイラ
    14.4　Ftraceの関数トレーサー
        14.4.1　traceの使い方
        14.4.2　trace_pipeの使い方
        14.4.3　オプション
    14.5　トレースポイント
        14.5.1　フィルタ
        14.5.2　トリガー
    14.6　kprobe
        14.6.1　イベントトレーシング
        14.6.2　引数
        14.6.3　戻り値
        14.6.4　フィルタとトリガー
        14.6.5　kprobeプロファイラ
    14.7　uprobe
        14.7.1　イベントトレーシング
        14.7.2　引数と戻り値
        14.7.3　フィルタとトリガー
        14.7.4　uprobeプロファイラ
    14.8　Ftraceの関数グラフトレーサー
        14.8.1　コールグラフのトレーシング
        14.8.2　オプション
    14.9　Ftraceのハードウェアレイテンシ（hwlat）トレーサー
    14.10　Ftrace histトリガー
        14.10.1　単一キー
        14.10.2　フィールド
        14.10.3　修飾子
        14.10.4　PIDフィルタ
        14.10.5　複数キー
        14.10.6　スタックトレースキー
        14.10.7　合成イベント
    14.11　trace-cmd
        14.11.1　サブコマンドの概要
        14.11.2　trace-cmdの1行プログラム
        14.11.3　trace-cmdと perf(1)
        14.11.4　trace-cmdによる関数グラフトレーシング
        14.11.5　KernelShark
        14.11.6　trace-cmdのドキュメント
    14.12　perf ftrace
    14.13　perf-tools
        14.13.1　対象領域
        14.13.2　単一目的ツール
        14.13.3　多目的ツール
        14.13.4　perf-toolsの1行プログラム
        14.13.5　例
        14.13.6　perf-toolsと BCC/BPF
        14.13.7　ドキュメント
    14.14　Ftraceのドキュメント
    14.15　参考文献

15章　BPF
    15.1　BCC
        15.1.1　インストール
        15.1.2　ツールの対象領域
        15.1.3　単一目的ツール
        15.1.4　多目的ツール
        15.1.5　1行プログラム
        15.1.6　多目的ツールの実行例
        15.1.7　BCCとbpftrace
        15.1.8　ドキュメント
    15.2　bpftrace
        15.2.1　インストール
        15.2.2　ツール
        15.2.3　
1行プログラム
        15.2.4　プログラミング
        15.2.5　リファレンス
        15.2.6　ドキュメント
    15.3　参考文献

16章　ケーススタディ
    16.1　予想外の成果
        16.1.1　問題の記述
        16.1.2　分析の戦略
        16.1.3　統計の数値
        16.1.4　構成
        16.1.5　PMC
        16.1.6　ソフトウェアイベント
        16.1.7　トレーシング
        16.1.8　結論
    16.2　その他の情報
    16.3　参考文献

付録A　USEメソッド: Linux
    A.1　物理リソース
        A.1.1　全般的な注
    A.2　ソフトウェアリソース
    A.3　参考文献

付録B　sarのまとめ

付録C　bpftrace1行プログラム
    C.1　CPU
    C.2　メモリ
    C.3　ファイルシステム
    C.4　ディスク
    C.5　ネットワーキング

付録D　練習問題の解答
    D.1　2章メソドロジ
    D.2　3章オペレーティングシステム
    D.3　6章 CPU
    D.4　7章メモリ
    D.5　8章ファイルシステム
    D.6　9章ディスク
    D.7　11章クラウドコンピューティング

付録E　システムパフォーマンス関連の著名人リスト
    E.1　参考文献

付録F　用語集
索引
</code></pre></div></article><footer class=py:24><div class="f:fade-30 f:14 mb:8"></div><div class="f:fade-60 f:12">Theme <a class=f:bold href=https://github.com/serkodev/holy _target=_blank>Holy</a></div></footer></div></div></body></html>